

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>humpack.packing &mdash; HumPack 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/gsm.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> HumPack
          

          
            
            <img src="../../_static/logo_border.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Intro</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../philosophy.html">Philosophy</a></li>
</ul>
<p class="caption"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../serialization.html">Serialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transactions.html">Transactions</a></li>
</ul>
<p class="caption"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../packable.html">Packing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../transactionable.html">Transactionable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../containers.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security.html">Secure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../errors.html">Errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../hashing.html">Hashing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../wrappers.html">Wrappers</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HumPack</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>humpack.packing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for humpack.packing</h1><div class="highlight"><pre>
<span></span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">NoReturn</span><span class="p">,</span> <span class="n">ClassVar</span><span class="p">,</span> <span class="n">TextIO</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">NewType</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">.errors</span> <span class="k">import</span> <span class="n">SavableClassCollisionError</span><span class="p">,</span> <span class="n">ObjectIDReadOnlyError</span><span class="p">,</span> <span class="n">UnregisteredClassError</span>

<span class="n">primitive</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span> <span class="c1"># all json readable and no sub elements</span>
<span class="c1"># all_primitives = , *primitive</span>

<span class="n">py_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">complex</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
<span class="n">py_containers</span> <span class="o">=</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">)</span>

<span class="n">_py_cls2name</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="o">*</span><span class="n">primitive</span><span class="p">,</span> <span class="o">*</span><span class="n">py_types</span><span class="p">,</span> <span class="o">*</span><span class="n">py_containers</span><span class="p">)}</span>
<span class="n">_py_name2cls</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">_py_cls2name</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<span class="k">def</span> <span class="nf">_full_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Find the full, unique name of a class by connecting it to the module where is is declared.</span>
<span class="sd">	</span>
<span class="sd">	:param cls: type</span>
<span class="sd">	:return: unique name of the class</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
	<span class="n">module</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">name</span>
	<span class="k">return</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">])</span>


<span class="n">_packable_registry</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_packable_cls</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">_packable_item</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Packable_Item&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;cls&#39;</span><span class="p">,</span> <span class="s1">&#39;pack_fn&#39;</span><span class="p">,</span> <span class="s1">&#39;create_fn&#39;</span><span class="p">,</span> <span class="s1">&#39;unpack_fn&#39;</span><span class="p">])</span>


<span class="n">_ref_prefix</span> <span class="o">=</span> <span class="s1">&#39;&lt;&gt;&#39;</span>
<span class="k">def</span> <span class="nf">_get_obj_id</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="s1">&#39;SERIALIZABLE&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Compute the object ID for packing objects, which must be unique and use the reference prefix</span>

<span class="sd">	:param obj: object to get the reference for</span>
<span class="sd">	:return: unique ID associated with `obj` for packing</span>
<span class="sd">	&#39;&#39;&#39;</span>
	
	<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">_get_cls_id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
	
	<span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_ref_prefix</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_get_cls_id</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Compute the object ID for packing classes, which must be unique and use the reference prefix</span>

<span class="sd">	:param cls: class to be packed</span>
<span class="sd">	:return: unique ID associated with `cls` for packing</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">_packable_cls</span><span class="p">:</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">_packable_cls</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
	<span class="k">elif</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">_py_cls2name</span><span class="p">:</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">_py_cls2name</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unknown class: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>
	
	<span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">_ref_prefix</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_cls</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClassVar</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Get the registered type from the registered name</span>
<span class="sd">	</span>
<span class="sd">	:param name:</span>
<span class="sd">	:return:</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_py_name2cls</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">_py_name2cls</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
	
	<span class="k">try</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">_packable_registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">cls</span>
	<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
		<span class="k">raise</span> <span class="n">UnregisteredClassError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_cls_from_ref</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ClassVar</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Recover the registered type from the reference thereof</span>
<span class="sd">	</span>
<span class="sd">	:param name: reference to a registered type</span>
<span class="sd">	:return: type</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">_ref_prefix</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
	<span class="k">return</span> <span class="n">get_cls</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="register_packable"><a class="viewcode-back" href="../../packable.html#humpack.packing.register_packable">[docs]</a><span class="k">def</span> <span class="nf">register_packable</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">,</span> <span class="n">pack_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">create_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">unpack_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
                      <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Register a type to be packable. Requires a pack_fn, create_fn, and unpack_fn to store and restore object state.</span>
<span class="sd">	</span>
<span class="sd">	:param cls: type to be registered</span>
<span class="sd">	:param pack_fn: callable input is an instance of the type, and packs all data necessary to recover the state</span>
<span class="sd">	:param create_fn: callable input is the expected type and the packed data, creates a new instance of the type,</span>
<span class="sd">	without unpacking any packed data (to avoid reference loops)</span>
<span class="sd">	:param unpack_fn: callable input is the instance of packed data and then restores that instance to the original</span>
<span class="sd">	state using the packed data by unpacking any values therein.</span>
<span class="sd">	:param name: (optional) name of the class used for storing</span>
<span class="sd">	:return: A `SavableClassCollisionError` if the name is already registered</span>
<span class="sd">	&#39;&#39;&#39;</span>
	
	<span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">_full_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
		
	<span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_packable_cls</span><span class="p">:</span>
		<span class="k">raise</span> <span class="n">SavableClassCollisionError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

	<span class="n">item</span> <span class="o">=</span> <span class="n">_packable_item</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">pack_fn</span><span class="p">,</span> <span class="n">create_fn</span><span class="p">,</span> <span class="n">unpack_fn</span><span class="p">)</span>
	<span class="n">_packable_registry</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
	<span class="n">_packable_cls</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span></div>

<div class="viewcode-block" id="Packable"><a class="viewcode-back" href="../../packable.html#humpack.packing.Packable">[docs]</a><span class="k">class</span> <span class="nc">Packable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Any subclass of this mixin can be serialized using `pack`</span>
<span class="sd">	</span>
<span class="sd">	All subclasses must implement __create__, __pack__, and __unpack__ to register the type. By passing a type to</span>
<span class="sd">	`use_cls` the type for which these methods are used can be overridden from the subclass.</span>
<span class="sd">	&#39;&#39;&#39;</span>
<div class="viewcode-block" id="Packable.__init_subclass__"><a class="viewcode-back" href="../../packable.html#humpack.packing.Packable.__init_subclass__">[docs]</a>	<span class="k">def</span> <span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">use_cls</span><span class="p">:</span> <span class="n">ClassVar</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		This method automatically registers any subclass that is declared.</span>
<span class="sd">		</span>
<span class="sd">		:param use_cls: The class to register (if it is different than `cls`)</span>
<span class="sd">		:return: None</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">()</span>
		
		<span class="k">if</span> <span class="n">use_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">use_cls</span> <span class="o">=</span> <span class="bp">cls</span>
		
		<span class="n">register_packable</span><span class="p">(</span><span class="n">use_cls</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__pack__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__create__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__unpack__</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Packable.__deepcopy__"><a class="viewcode-back" href="../../packable.html#humpack.packing.Packable.__deepcopy__">[docs]</a>	<span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memodict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Produces a deep copy of the data by packing and repacking.</span>
<span class="sd">		</span>
<span class="sd">		:param memodict: Unused</span>
<span class="sd">		:return: A deep copy of self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="n">unpack</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>
	
<div class="viewcode-block" id="Packable.__create__"><a class="viewcode-back" href="../../packable.html#humpack.packing.Packable.__create__">[docs]</a>	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">__create__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;PACKED&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;Packable&#39;</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Create the object without loading the state from data. You can use the data to inform how</span>
<span class="sd">		to initialize the object, however no stored objects should be unpacked (to avoid reference loops)</span>
<span class="sd">		</span>
<span class="sd">		:param data: packed data to restore object state, should NOT be unpacked here</span>
<span class="sd">		:return: A fresh instance of the class registered with this create_fn</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span></div>
	
<div class="viewcode-block" id="Packable.__pack__"><a class="viewcode-back" href="../../packable.html#humpack.packing.Packable.__pack__">[docs]</a>	<span class="k">def</span> <span class="nf">__pack__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="s1">&#39;PACKED&#39;</span><span class="p">]:</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Collect all data in self necessary to store the state.</span>
<span class="sd">		</span>
<span class="sd">		.. warning:: All data must be &quot;packed&quot; storing it. This is done by passing the data into</span>
<span class="sd">		`Packable._pack_obj` and using what is returned.</span>
<span class="sd">		</span>
<span class="sd">		:return: A dict of packed data necessary to recover the state of self</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
	
<div class="viewcode-block" id="Packable.__unpack__"><a class="viewcode-back" href="../../packable.html#humpack.packing.Packable.__unpack__">[docs]</a>	<span class="k">def</span> <span class="nf">__unpack__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;PACKED&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
		<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">		Using `data`, recover the packed state.</span>
<span class="sd">		Must be overridden by all subclasses.</span>
<span class="sd">		</span>
<span class="sd">		.. warning:: All data must be &quot;unpacked&quot; before using it. This is done by passing the data into</span>
<span class="sd">		`Packable._unpack_obj` and using what is returned.</span>
<span class="sd">		</span>
<span class="sd">		:param data: The information that is returned by `__pack__`.</span>
<span class="sd">		:return: Nothing. Once returned, the object should be in the same state as when it was packed</span>
<span class="sd">		&#39;&#39;&#39;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<span class="n">PRIMITIVE</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">primitive</span><span class="p">]</span>
<span class="sd">&#39;&#39;&#39;Valid primitives&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1"># SERIALIZABLE = Union[Packable, PRIMITIVE, Dict[&#39;SERIALIZABLE&#39;, &#39;SERIALIZABLE&#39;],</span>
<span class="c1">#                      List[&#39;SERIALIZABLE&#39;], Set[&#39;SERIALIZABLE&#39;], Tuple[&#39;SERIALIZABLE&#39;]]</span>
<span class="c1"># &#39;&#39;&#39;Types that can be serialized using `pack`&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1"># JSONABLE = Union[Dict[str,&#39;JSONABLE&#39;], List[&#39;JSONABLE&#39;], PRIMITIVE]</span>
<span class="c1"># &#39;&#39;&#39;Any object that is valid in json (eg. using `json.dumps`)&#39;&#39;&#39;</span>
<span class="c1">#</span>
<span class="c1"># PACKED = Union[PRIMITIVE, List[&#39;PACKED&#39;], Dict[&#39;PACKED&#39;, &#39;PACKED&#39;]]</span>
<span class="c1"># &#39;&#39;&#39;Any information that is valid json and can be unpacked to recover the state of `Packable` subclasses.&#39;&#39;&#39;</span>



<span class="n">SERIALIZABLE</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;SERIALIZABLE&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
<span class="n">JSONABLE</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;JSONABLE&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
<span class="n">PACKED</span> <span class="o">=</span> <span class="n">NewType</span><span class="p">(</span><span class="s1">&#39;PACKED&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>


<span class="n">_ref_table</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_obj_table</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="pack_data"><a class="viewcode-back" href="../../packable.html#humpack.packing.pack_data">[docs]</a><span class="k">def</span> <span class="nf">pack_data</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SERIALIZABLE</span><span class="p">,</span> <span class="n">force_str</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PACKED</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Store the object state by packing it, possibly returning a reference.</span>
<span class="sd">	</span>
<span class="sd">	This function should be called inside implemented __pack__ on all data in an object necessary to restore</span>
<span class="sd">	the object state.</span>
<span class="sd">	</span>
<span class="sd">	Note: this function should not be called on the top level (use `pack` instead).</span>
<span class="sd">	</span>
<span class="sd">	:param obj: serializable data that should be packed</span>
<span class="sd">	:param force_str: if the data is a key for a dict, set this to true to ensure the key is a str</span>
<span class="sd">	:return: packed data</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">primitive</span><span class="p">):</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_ref_prefix</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">force_str</span><span class="p">):</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="n">_get_obj_id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
			<span class="n">_ref_table</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;_type&#39;</span><span class="p">:</span> <span class="n">_py_cls2name</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)],</span> <span class="s1">&#39;_data&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}</span>
		<span class="k">elif</span> <span class="n">force_str</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="n">_get_obj_id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
			<span class="n">_ref_table</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;_type&#39;</span><span class="p">:</span> <span class="n">_py_cls2name</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)],</span> <span class="s1">&#39;_data&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">obj</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">_get_obj_id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
		<span class="n">typ</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">_ref_table</span> <span class="ow">or</span> <span class="n">typ</span> <span class="o">==</span> <span class="nb">type</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">ref</span>
		<span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="n">_ref_table</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>  <span class="c1"># create entry in refs to stop reference loops</span>
		<span class="k">if</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">_packable_cls</span><span class="p">:</span>
			<span class="n">info</span> <span class="o">=</span> <span class="n">_packable_cls</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>

			<span class="n">data</span><span class="p">[</span><span class="s1">&#39;_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">name</span>
			<span class="n">data</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">pack_fn</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

		<span class="k">elif</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">_py_cls2name</span><span class="p">:</span>  <span class="c1"># known python types</span>
			<span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
				<span class="n">data</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">pack_data</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">force_str</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span> <span class="n">pack_data</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
			<span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="nb">range</span><span class="p">:</span>
				<span class="n">data</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;start&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">step</span><span class="p">}</span>
			<span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="nb">complex</span><span class="p">:</span>
				<span class="n">data</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">imag</span><span class="p">]</span>
			<span class="k">elif</span> <span class="n">typ</span> <span class="o">==</span> <span class="nb">bytes</span><span class="p">:</span>
				<span class="n">data</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;latin1&#39;</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">data</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pack_data</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
			<span class="n">data</span><span class="p">[</span><span class="s1">&#39;_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_py_cls2name</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized type: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>
	
	<span class="k">return</span> <span class="n">ref</span></div>

<div class="viewcode-block" id="unpack_data"><a class="viewcode-back" href="../../packable.html#humpack.packing.unpack_data">[docs]</a><span class="k">def</span> <span class="nf">unpack_data</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">PACKED</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SERIALIZABLE</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Restore the object data by unpacking it.</span>
<span class="sd">	</span>
<span class="sd">	This function should be called inside implemented __unpack__ on all data in an object necessary to restore</span>
<span class="sd">	the object state from the packed data.</span>
<span class="sd">	</span>
<span class="sd">	Note: this function should not be called on the top level (use `unpack` instead).</span>
<span class="sd">	</span>
<span class="sd">	:param data: packed data that should be unpacked</span>
<span class="sd">	:return: unpacked data to restore the state</span>
<span class="sd">	&#39;&#39;&#39;</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_ref_prefix</span><span class="p">):</span>  <span class="c1"># reference or class</span>

		<span class="k">if</span> <span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>  <span class="c1"># class</span>
			<span class="k">return</span> <span class="n">get_cls_from_ref</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
		
		<span class="k">elif</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">_obj_table</span><span class="p">:</span>  <span class="c1"># reference</span>
			<span class="k">return</span> <span class="n">_obj_table</span><span class="p">[</span><span class="n">data</span><span class="p">]</span>

		<span class="k">else</span><span class="p">:</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="n">data</span>
			<span class="n">typname</span> <span class="o">=</span> <span class="n">_ref_table</span><span class="p">[</span><span class="n">ref</span><span class="p">][</span><span class="s1">&#39;_type&#39;</span><span class="p">]</span>
			<span class="n">data</span> <span class="o">=</span> <span class="n">_ref_table</span><span class="p">[</span><span class="n">ref</span><span class="p">][</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span>
			<span class="n">item</span> <span class="o">=</span> <span class="kc">None</span>
			
			<span class="k">if</span> <span class="n">typname</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;str&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">}:</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="n">data</span>
			<span class="k">elif</span> <span class="n">typname</span> <span class="o">==</span> <span class="s1">&#39;tuple&#39;</span><span class="p">:</span>  <span class="c1"># since tuples are immutable they have to created right away (no loop issues)</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unpack_data</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">typname</span> <span class="o">==</span> <span class="s1">&#39;range&#39;</span><span class="p">:</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;stop&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">])</span>
			<span class="k">elif</span> <span class="n">typname</span> <span class="o">==</span> <span class="s1">&#39;bytes&#39;</span><span class="p">:</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;latin1&#39;</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">typname</span> <span class="o">==</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">typname</span> <span class="ow">in</span> <span class="n">_py_name2cls</span><span class="p">:</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="n">_py_name2cls</span><span class="p">[</span><span class="n">typname</span><span class="p">]()</span>
			<span class="k">else</span><span class="p">:</span>  <span class="c1"># must be an instance of Packable</span>
				<span class="n">item</span> <span class="o">=</span> <span class="n">_packable_registry</span><span class="p">[</span><span class="n">typname</span><span class="p">]</span>
				<span class="n">obj</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">create_fn</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
				
			<span class="k">del</span> <span class="n">_ref_table</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span>
			<span class="n">_obj_table</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

			<span class="c1"># after adding empty obj to obj table, populate obj with state from data</span>
			<span class="k">if</span> <span class="n">typname</span> <span class="o">==</span> <span class="s1">&#39;dict&#39;</span><span class="p">:</span>
				<span class="n">obj</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">unpack_data</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="n">unpack_data</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
			<span class="k">elif</span> <span class="n">typname</span> <span class="o">==</span> <span class="s1">&#39;set&#39;</span><span class="p">:</span>
				<span class="n">obj</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">unpack_data</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">typname</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
				<span class="n">obj</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">unpack_data</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span>
			<span class="k">elif</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">item</span><span class="o">.</span><span class="n">unpack_fn</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">primitive</span><span class="p">),</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">data</span>
	
	<span class="k">return</span> <span class="n">obj</span></div>

<div class="viewcode-block" id="pack"><a class="viewcode-back" href="../../packable.html#humpack.packing.pack">[docs]</a><span class="k">def</span> <span class="nf">pack</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SERIALIZABLE</span><span class="p">,</span> <span class="n">meta</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PACKED</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_timestamp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">JSONABLE</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Serializes any object, returning a json object that can be converted to a json string.</span>
<span class="sd">	</span>
<span class="sd">	:param obj: Object to be serialized</span>
<span class="sd">	:param meta: Meta information, must be jsonable</span>
<span class="sd">	:param include_timestamp: include a timestamp in the meta information</span>
<span class="sd">	:return: packed data, which can be converted to a json string using json.dumps</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">global</span> <span class="n">_ref_table</span>
	<span class="n">_ref_table</span> <span class="o">=</span> <span class="p">{}</span>

	<span class="k">try</span><span class="p">:</span>
		<span class="n">out</span> <span class="o">=</span> <span class="n">pack_data</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

		<span class="c1"># additional meta info</span>
		<span class="k">if</span> <span class="n">meta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">if</span> <span class="n">include_timestamp</span><span class="p">:</span>
			<span class="n">meta</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">_%H%M%S&#39;</span><span class="p">)</span>

		<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
			<span class="s1">&#39;table&#39;</span><span class="p">:</span> <span class="n">_ref_table</span><span class="p">,</span>
			<span class="s1">&#39;meta&#39;</span><span class="p">:</span> <span class="n">meta</span><span class="p">,</span>
			<span class="s1">&#39;head&#39;</span><span class="p">:</span> <span class="n">out</span><span class="p">,</span> <span class="c1"># save parent object separately</span>
		<span class="p">}</span>

	<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
		<span class="k">raise</span> <span class="n">e</span>
	<span class="k">finally</span><span class="p">:</span>
		<span class="n">_ref_table</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="unpack"><a class="viewcode-back" href="../../packable.html#humpack.packing.unpack">[docs]</a><span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">PACKED</span><span class="p">,</span> <span class="n">return_meta</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SERIALIZABLE</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Deserialize a packed object to recover the original state.</span>
<span class="sd">	</span>
<span class="sd">	:param data: serialized (packed) state of an object</span>
<span class="sd">	:param return_meta: return any meta information from the serialized data</span>
<span class="sd">	:return: the unpacked (restored) object</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="c1"># add the current cls.__ID_counter to all loaded objs</span>
	<span class="k">global</span> <span class="n">_ref_table</span><span class="p">,</span> <span class="n">_obj_table</span>
	<span class="n">_ref_table</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
	<span class="n">_obj_table</span> <span class="o">=</span> <span class="p">{}</span>

	<span class="k">try</span><span class="p">:</span>
		<span class="n">obj</span> <span class="o">=</span> <span class="n">unpack_data</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;head&#39;</span><span class="p">])</span>
	<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
		<span class="k">raise</span> <span class="n">e</span>
	<span class="k">finally</span><span class="p">:</span>
		<span class="n">_ref_table</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="n">_obj_table</span> <span class="o">=</span> <span class="kc">None</span>

	<span class="k">if</span> <span class="n">return_meta</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;meta&#39;</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">obj</span></div>


<div class="viewcode-block" id="save_pack"><a class="viewcode-back" href="../../packable.html#humpack.packing.save_pack">[docs]</a><span class="k">def</span> <span class="nf">save_pack</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SERIALIZABLE</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">TextIO</span><span class="p">,</span> <span class="n">meta</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">JSONABLE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">include_timestamp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Pack (serialize) the object and store it as a json file</span>
<span class="sd">	</span>
<span class="sd">	:param obj: object to be packed</span>
<span class="sd">	:param fp: writable file-like object where the packed object is stored</span>
<span class="sd">	:param include_timestamp: include timestamp in meta information</span>
<span class="sd">	:return: None</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">meta</span><span class="p">,</span> <span class="n">include_timestamp</span><span class="o">=</span><span class="n">include_timestamp</span><span class="p">),</span> <span class="n">fp</span><span class="p">)</span></div>

<div class="viewcode-block" id="load_pack"><a class="viewcode-back" href="../../packable.html#humpack.packing.load_pack">[docs]</a><span class="k">def</span> <span class="nf">load_pack</span><span class="p">(</span><span class="n">fp</span><span class="p">:</span> <span class="n">TextIO</span><span class="p">,</span> <span class="n">return_meta</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SERIALIZABLE</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Loads json file of packed object and unpacks the object</span>
<span class="sd">	</span>
<span class="sd">	:param fp: writable file-like object</span>
<span class="sd">	:param return_meta: return the meta information stored</span>
<span class="sd">	:return: unpacked object from json file</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">return</span> <span class="n">unpack</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">fp</span><span class="p">),</span> <span class="n">return_meta</span><span class="o">=</span><span class="n">return_meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="json_pack"><a class="viewcode-back" href="../../packable.html#humpack.packing.json_pack">[docs]</a><span class="k">def</span> <span class="nf">json_pack</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SERIALIZABLE</span><span class="p">,</span> <span class="n">meta</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">JSONABLE</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">include_timestamp</span><span class="p">:</span><span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Pack object and return a json string of the serialized object</span>
<span class="sd">	</span>
<span class="sd">	:param obj: to be packed</span>
<span class="sd">	:param meta: any meta information to include</span>
<span class="sd">	:param include_timestamp: include timestamp in meta information</span>
<span class="sd">	:return: json string of the serialized data</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">include_timestamp</span><span class="o">=</span><span class="n">include_timestamp</span><span class="p">))</span></div>

<div class="viewcode-block" id="json_unpack"><a class="viewcode-back" href="../../packable.html#humpack.packing.json_unpack">[docs]</a><span class="k">def</span> <span class="nf">json_unpack</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">return_meta</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SERIALIZABLE</span><span class="p">:</span>
	<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">	Unpack json string of a packed object.</span>
<span class="sd">	</span>
<span class="sd">	:param data: json string of a packed object</span>
<span class="sd">	:param return_meta: return meta information</span>
<span class="sd">	:return: unpacked object</span>
<span class="sd">	&#39;&#39;&#39;</span>
	<span class="k">return</span> <span class="n">unpack</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">return_meta</span><span class="o">=</span><span class="n">return_meta</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Felix Leeb

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>